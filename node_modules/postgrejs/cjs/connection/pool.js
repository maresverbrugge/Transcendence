"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pool = void 0;
const lightning_pool_1 = require("lightning-pool");
const putil_varhelpers_1 = require("putil-varhelpers");
const constants_js_1 = require("../constants.js");
const safe_event_emitter_js_1 = require("../safe-event-emitter.js");
const connection_config_js_1 = require("../util/connection-config.js");
const connection_js_1 = require("./connection.js");
const intl_connection_js_1 = require("./intl-connection.js");
class Pool extends safe_event_emitter_js_1.SafeEventEmitter {
    constructor(config) {
        super();
        this._notificationListeners = new safe_event_emitter_js_1.SafeEventEmitter();
        const cfg = (0, connection_config_js_1.getConnectionConfig)(config);
        this.config = Object.freeze(cfg);
        const poolOptions = {};
        poolOptions.acquireMaxRetries = (0, putil_varhelpers_1.coerceToInt)(cfg.acquireMaxRetries, 0);
        poolOptions.acquireRetryWait = (0, putil_varhelpers_1.coerceToInt)(cfg.acquireRetryWait, 2000);
        poolOptions.acquireTimeoutMillis = (0, putil_varhelpers_1.coerceToInt)(cfg.acquireTimeoutMillis, 0);
        poolOptions.idleTimeoutMillis = (0, putil_varhelpers_1.coerceToInt)(cfg.idleTimeoutMillis, 30000);
        poolOptions.max = (0, putil_varhelpers_1.coerceToInt)(cfg.max, 10);
        poolOptions.maxQueue = (0, putil_varhelpers_1.coerceToInt)(cfg.maxQueue, 1000);
        poolOptions.max = (0, putil_varhelpers_1.coerceToInt)(cfg.max, 10);
        poolOptions.min = (0, putil_varhelpers_1.coerceToInt)(cfg.min, 0);
        poolOptions.minIdle = (0, putil_varhelpers_1.coerceToInt)(cfg.minIdle, 0);
        poolOptions.validation = (0, putil_varhelpers_1.coerceToBoolean)(cfg.validation, false);
        const poolFactory = {
            create: async () => {
                /* istanbul ignore next */
                if (this.listenerCount('debug')) {
                    this.emit('debug', {
                        location: 'Pool.factory.create',
                        pool: this,
                        message: `new connection creating`,
                    });
                }
                const intlCon = new intl_connection_js_1.IntlConnection(cfg);
                await intlCon.connect();
                intlCon.on('close', () => this._pool.destroy(intlCon));
                /* istanbul ignore next */
                if (this.listenerCount('debug')) {
                    this.emit('debug', {
                        location: 'Pool.factory.create',
                        pool: this,
                        message: `[${intlCon.processID}] connection created`,
                    });
                }
                return intlCon;
            },
            destroy: intlCon => {
                /* istanbul ignore next */
                if (this.listenerCount('debug')) {
                    this.emit('debug', {
                        location: 'Pool.factory.destroy',
                        pool: this,
                        message: `[${intlCon.processID}] connection destroy`,
                    });
                }
                return intlCon.close();
            },
            reset: async (intlCon) => {
                /* istanbul ignore next */
                if (this.listenerCount('debug')) {
                    this.emit('debug', {
                        location: 'Pool.factory.reset',
                        pool: this,
                        message: `[${intlCon.processID}] connection reset`,
                    });
                }
                try {
                    if (intlCon.state === constants_js_1.ConnectionState.READY) {
                        await intlCon.execute('ROLLBACK;UNLISTEN *');
                    }
                }
                finally {
                    intlCon.removeAllListeners();
                    intlCon.once('close', () => this._pool.destroy(intlCon));
                    intlCon._refCount = 0;
                }
            },
            validate: async (intlCon) => {
                /* istanbul ignore next */
                if (this.listenerCount('debug')) {
                    this.emit('debug', {
                        location: 'Pool.factory.validate',
                        pool: this,
                        message: `[${intlCon.processID}] connection validate`,
                    });
                }
                if (intlCon.state !== constants_js_1.ConnectionState.READY)
                    throw new Error('Connection is not active');
                await intlCon.execute('select 1;');
            },
        };
        this._pool = new lightning_pool_1.Pool(poolFactory, poolOptions);
        this._pool.on('return', (...args) => this.emit('release', ...args));
        this._pool.on('error', (...args) => this.emit('error', ...args));
        this._pool.on('acquire', (...args) => this.emit('acquire', ...args));
        this._pool.on('destroy', (...args) => this.emit('destroy', ...args));
        this._pool.start();
    }
    /**
     * Returns number of connections that are currently acquired
     */
    get acquiredConnections() {
        return this._pool.acquired;
    }
    /**
     * Returns number of unused connections in the pool
     */
    get idleConnections() {
        return this._pool.available;
    }
    /**
     * Returns total number of connections in the pool regardless of whether they are idle or in use
     */
    get totalConnections() {
        return this._pool.size;
    }
    /**
     * Obtains a connection from the connection pool
     */
    async acquire() {
        const intlCon = await this._pool.acquire();
        /* istanbul ignore next */
        if (this.listenerCount('debug')) {
            this.emit('debug', {
                location: 'Pool.acquire',
                pool: this,
                message: `[${intlCon.processID}] acquired`,
            });
        }
        const connection = new connection_js_1.Connection(this, intlCon);
        /* istanbul ignore next */
        if (this.listenerCount('debug'))
            connection.on('debug', (...args) => this.emit('debug', ...args));
        return connection;
    }
    /**
     * Shuts down the pool and destroys all resources.
     */
    async close(terminateWait) {
        this._notificationListeners.removeAllListeners();
        await this._notificationConnection?.close(terminateWait);
        const ms = terminateWait == null ? 10000 : terminateWait;
        return this._pool.closeAsync(ms);
    }
    /**
     * Executes a script
     */
    async execute(sql, options) {
        const connection = await this.acquire();
        try {
            return await connection.execute(sql, options);
        }
        finally {
            await this.release(connection);
        }
    }
    /**
     * Executes a query
     */
    async query(sql, options) {
        const connection = await this.acquire();
        try {
            return await connection.query(sql, options);
        }
        finally {
            await this.release(connection);
        }
    }
    async prepare(sql, options) {
        const connection = await this.acquire();
        const statement = await connection.prepare(sql, options);
        statement.once('close', () => this._pool.release((0, intl_connection_js_1.getIntlConnection)(connection)));
        return statement;
    }
    release(connection) {
        return this._pool.releaseAsync((0, intl_connection_js_1.getIntlConnection)(connection));
    }
    async listen(channel, callback) {
        if (!/^[A-Z]\w+$/i.test(channel))
            throw new TypeError(`Invalid channel name`);
        this._notificationListeners.on(channel, callback);
        await this._initNotificationConnection();
    }
    async unListen(channel) {
        if (!/^[A-Z]\w+$/i.test(channel))
            throw new TypeError(`Invalid channel name`);
        this._notificationListeners.removeAllListeners(channel);
        if (!this._notificationListeners.eventNames().length) {
            await this.unListenAll();
        }
        else if (this._notificationConnection)
            await this._notificationConnection.unListen(channel);
    }
    async unListenAll() {
        this._notificationListeners.removeAllListeners();
        if (this._notificationConnection) {
            const conn = this._notificationConnection;
            this._notificationConnection = undefined;
            await conn.close();
        }
    }
    async _initNotificationConnection() {
        if (this._notificationConnection)
            return;
        const conn = (this._notificationConnection = new connection_js_1.Connection(this.config));
        // Reconnect on connection lost
        conn.on('close', () => reConnect());
        const registerEvents = async () => {
            const channels = this._notificationListeners.eventNames();
            for (const channel of channels) {
                const fns = this._notificationListeners.listeners(channel);
                for (const fn of fns) {
                    await conn.listen(channel, fn);
                }
            }
        };
        const reConnect = async () => {
            setTimeout(() => {
                if (!this._notificationListeners.eventNames().length)
                    return;
                conn.connect().catch(() => reConnect());
            }, 500).unref();
        };
        await conn.connect();
        await registerEvents();
    }
}
exports.Pool = Pool;
