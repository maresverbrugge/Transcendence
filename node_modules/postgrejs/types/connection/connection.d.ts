import { ConnectionState } from '../constants.js';
import { ConnectionConfiguration } from '../interfaces/database-connection-params.js';
import { QueryOptions } from '../interfaces/query-options.js';
import { QueryResult } from '../interfaces/query-result.js';
import { ScriptExecuteOptions } from '../interfaces/script-execute-options.js';
import { ScriptResult } from '../interfaces/script-result.js';
import { StatementPrepareOptions } from '../interfaces/statement-prepare-options.js';
import { DatabaseError } from '../protocol/database-error.js';
import { Protocol } from '../protocol/protocol.js';
import { SafeEventEmitter } from '../safe-event-emitter.js';
import { Maybe } from '../types.js';
import { IntlConnection } from './intl-connection.js';
import type { Pool } from './pool.js';
import { PreparedStatement } from './prepared-statement.js';
export type NotificationMessage = Protocol.NotificationResponseMessage;
export type NotificationCallback = (msg: NotificationMessage) => any;
export declare class Connection extends SafeEventEmitter implements AsyncDisposable {
    protected readonly _pool?: Pool;
    protected readonly _intlCon: IntlConnection;
    protected readonly _notificationListeners: SafeEventEmitter;
    protected _closing: boolean;
    constructor(pool: Pool, intlCon: IntlConnection);
    constructor(config?: ConnectionConfiguration | string);
    /**
     * Returns configuration object
     */
    get config(): ConnectionConfiguration;
    /**
     * Returns true if connection is in a transaction
     */
    get inTransaction(): boolean;
    /**
     * Returns current state of the connection
     */
    get state(): ConnectionState;
    /**
     * Returns processId of current session
     */
    get processID(): Maybe<number>;
    /**
     * Returns information parameters for current session
     */
    get sessionParameters(): Record<string, string>;
    /**
     * Returns secret key of current session
     */
    get secretKey(): Maybe<number>;
    /**
     * Connects to the server
     */
    connect(): Promise<void>;
    /**
     * Closes connection. You can define how long time the connection will
     * wait for active queries before terminating the connection.
     * On the end of the given time, it forces to close the socket and than emits `terminate` event.
     *
     * @param terminateWait {number} - Determines how long the connection will wait for active queries before terminating.
     */
    close(terminateWait?: number): Promise<void>;
    /**
     * Executes single or multiple SQL scripts using Simple Query protocol.
     *
     * @param sql {string} - SQL script that will be executed
     * @param options {ScriptExecuteOptions} - Execute options
     */
    execute(sql: string, options?: ScriptExecuteOptions): Promise<ScriptResult>;
    query(sql: string, options?: QueryOptions): Promise<QueryResult>;
    /**
     * Creates a PreparedStatement instance
     * @param sql {string} - SQL script that will be executed
     * @param options {StatementPrepareOptions} - Options
     */
    prepare(sql: string, options?: StatementPrepareOptions): Promise<PreparedStatement>;
    /**
     * Starts a transaction
     */
    startTransaction(): Promise<void>;
    /**
     * Commits current transaction
     */
    commit(): Promise<void>;
    /**
     * Rolls back current transaction
     */
    rollback(): Promise<void>;
    /**
     * Starts transaction and creates a savepoint
     * @param name {string} - Name of the savepoint
     */
    savepoint(name: string): Promise<void>;
    /**
     * Rolls back current transaction to given savepoint
     * @param name {string} - Name of the savepoint
     */
    rollbackToSavepoint(name: string): Promise<void>;
    /**
     * Releases savepoint
     * @param name {string} - Name of the savepoint
     */
    releaseSavepoint(name: string): Promise<void>;
    listen(channel: string, callback: NotificationCallback): Promise<void>;
    unListen(channel: string): Promise<void>;
    unListenAll(): Promise<void>;
    protected _handleNotification(msg: NotificationMessage): void;
    protected _close(): Promise<void>;
    protected _handleError(err: DatabaseError, script: string): DatabaseError;
    protected _captureErrorStack<T>(promise: Promise<T>): Promise<T>;
    [Symbol.asyncDispose](): Promise<void>;
}
