import { AsyncEventEmitter } from "strict-typed-events";
export type TaskFunction<T = any> = (args: TaskFunctionArgs) => T | Promise<T>;
export type TaskLike<T = any> = Task<T> | TaskFunction;
export type TaskStatus = "idle" | "waiting" | "running" | "fulfilled" | "failed" | "aborting" | "aborted";
export interface TaskFunctionArgs {
    task: Task;
    signal: AbortSignal;
}
export interface TaskOptions {
    /**
     * Id of the task.
     */
    id?: any;
    /**
     * Name of the task. This value is used to for dependency tree
     */
    name?: string;
    /**
     * Arguments to be passed to task function.
     */
    args?: any[];
    /**
     * The list of child tasks
     */
    children?: TaskLike[] | (() => TaskLike[] | Promise<TaskLike[]>);
    /**
     * The list of tasks to be waited before running this task.
     */
    dependencies?: (Task | string)[];
    /**
     * Number of concurrent tasks to run in parallel
     */
    concurrency?: number;
    /**
     * Abort after first task failure
     */
    bail?: boolean;
    /**
     * Run tasks one by one
     */
    serial?: boolean;
    /**
     * Run the task exclusively. If set true, the tasks in the queue waits for this task to complete
     * even concurrency is greater than 1
     */
    exclusive?: boolean;
    /**
     * Time in milliseconds to wait for aborting tasks
     */
    abortTimeout?: number;
    onStart?: (task: Task) => void;
    onFinish?: (task: Task) => void;
    onRun?: (task: Task) => void;
    onStatusChange?: (task: Task) => void;
    onUpdate?: (task: Task, properties: string[]) => void;
    onUpdateRecursive?: (task: Task, properties: string[]) => void;
}
export interface TaskUpdateValues {
    status?: TaskStatus;
    message?: string;
    error?: any;
    result?: any;
    waitingFor?: boolean;
}
declare class TaskContext {
    executingTasks: Set<Task<any>>;
    queue: Set<Task<any>>;
    concurrency: number;
    triggerPulse: () => void;
}
declare const taskContextKey: unique symbol;
export declare class Task<T = any> extends AsyncEventEmitter {
    protected [taskContextKey]?: TaskContext;
    protected _id: string;
    protected _options: TaskOptions;
    protected _executeFn?: TaskFunction;
    protected _children?: Task[];
    protected _dependencies?: Task[];
    protected _status: TaskStatus;
    protected _message?: string;
    protected _executeDuration?: number;
    protected _error?: any;
    protected _result?: T;
    protected _isManaged?: boolean;
    protected _abortController: AbortController;
    protected _abortTimer?: NodeJS.Timeout;
    protected _waitingFor?: Set<Task>;
    protected _failedChildren?: Task[];
    protected _abortedChildren?: Task[];
    protected _failedDependencies?: Task[];
    protected _childrenLeft?: Set<Task>;
    constructor(children: TaskLike[], options?: Omit<TaskOptions, "children">);
    constructor(execute: TaskFunction, options?: TaskOptions);
    get id(): string;
    get name(): string | undefined;
    get children(): Task[] | undefined;
    get options(): TaskOptions;
    get message(): string;
    get status(): TaskStatus;
    get isStarted(): boolean;
    get isFinished(): boolean;
    get isFailed(): boolean;
    get executeDuration(): number | undefined;
    get result(): any;
    get error(): any;
    get dependencies(): Task[] | undefined;
    get failedChildren(): Task[] | undefined;
    get failedDependencies(): Task[] | undefined;
    get needWaiting(): boolean;
    getWaitingTasks(): Task[] | undefined;
    abort(): this;
    start(): this;
    toPromise(): Promise<T>;
    protected _determineChildrenTree(callback: (err?: any) => void): void;
    protected _determineChildrenDependencies(scope: Task[]): void;
    protected _captureDependencies(): void;
    protected _start(): void;
    protected _startChildren(): void;
    protected _pulse(): void;
    protected _update(prop: TaskUpdateValues): void;
    protected _abortChildren(): Promise<void>;
}
export {};
