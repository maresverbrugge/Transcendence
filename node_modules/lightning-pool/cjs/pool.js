"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pool = void 0;
const tslib_1 = require("tslib");
const doublylinked_1 = tslib_1.__importDefault(require("doublylinked"));
const events_1 = require("events");
const putil_promisify_1 = tslib_1.__importDefault(require("putil-promisify"));
const abort_error_js_1 = require("./abort-error.js");
const definitions_js_1 = require("./definitions.js");
const pool_options_js_1 = require("./pool-options.js");
const pool_request_js_1 = require("./pool-request.js");
const resource_item_js_1 = require("./resource-item.js");
class Pool extends events_1.EventEmitter {
    constructor(factory, config) {
        super();
        this._requestQueue = new doublylinked_1.default();
        this._allResources = new Map();
        this._acquiredResources = new doublylinked_1.default();
        this._idleResources = new doublylinked_1.default();
        this._creating = 0;
        this._requestsProcessing = 0;
        this._state = definitions_js_1.PoolState.IDLE;
        if (typeof factory !== 'object') {
            throw new TypeError('You must provide `factory` object');
        }
        if (typeof factory.create !== 'function') {
            throw new TypeError('factory.create must be a function');
        }
        if (typeof factory.destroy !== 'function') {
            throw new TypeError('factory.destroy must be a function');
        }
        if (factory.validate && typeof factory.validate !== 'function') {
            throw new TypeError('factory.validate can be a function');
        }
        if (factory.reset && typeof factory.reset !== 'function') {
            throw new TypeError('factory.reset can be a function');
        }
        const opts = (this._options = new pool_options_js_1.PoolOptions(this));
        opts.on('change', (prop, val) => {
            if (prop === 'houseKeepInterval')
                this._setHouseKeep(val);
            if (prop === 'min' || prop === 'minIdle')
                this._ensureMin();
        });
        if (config)
            this.options.assign(config);
        this._factory = factory;
    }
    /**
     * Returns Pool options
     */
    get options() {
        return this._options;
    }
    /**
     * Returns number of resources that are currently acquired
     */
    get acquired() {
        return this._acquiredResources.length;
    }
    /**
     * Returns number of unused resources in the pool
     */
    get available() {
        return this._idleResources.length;
    }
    /**
     * Returns number of resources currently creating
     */
    get creating() {
        return this._creating;
    }
    /**
     * Returns number of callers waiting to acquire a resource
     */
    get pending() {
        return this._requestQueue.length + this._requestsProcessing;
    }
    /**
     * Returns number of resources in the pool
     * regardless of whether they are idle or in use
     */
    get size() {
        return this._allResources.size;
    }
    /**
     * Returns state of the pool
     */
    get state() {
        return this._state;
    }
    /**
     * Starts the pool and begins creating of resources, starts house keeping and any other internal logic.
     * Note: This method is not need to be called. Pool instance will automatically be started when acquire() method is called
     */
    start() {
        if (this._state === definitions_js_1.PoolState.STARTED)
            return;
        if (this._state >= definitions_js_1.PoolState.CLOSING) {
            throw new Error('Closed pool can not be started again');
        }
        this._state = definitions_js_1.PoolState.STARTED;
        this._setHouseKeep(this.options.houseKeepInterval);
        this._ensureMin();
        this.emit('start');
    }
    close(arg0, arg1) {
        let terminateWait = Infinity;
        let callback;
        if (typeof arg0 === 'function')
            callback = arg0;
        else {
            terminateWait = typeof arg0 === 'number' ? arg0 : arg0 ? 0 : Infinity;
            callback = arg1;
        }
        if (!callback) {
            return putil_promisify_1.default.fromCallback(cb => this.close(terminateWait, cb));
        }
        if (this._state === definitions_js_1.PoolState.CLOSED || this._state === definitions_js_1.PoolState.IDLE) {
            return callback();
        }
        if (this._state === definitions_js_1.PoolState.CLOSING) {
            this.once('close', callback);
            return;
        }
        this.emit('closing');
        if (this._houseKeepTimer)
            clearTimeout(this._houseKeepTimer);
        this._state = definitions_js_1.PoolState.CLOSING;
        this._requestQueue.forEach(t => t.stopTimout());
        this._requestQueue = new doublylinked_1.default();
        this._requestsProcessing = 0;
        if (terminateWait <= 0) {
            this._acquiredResources.forEach(t => this.destroy(t.resource));
        }
        else {
            const startTime = Date.now();
            this._closeWaitTimer = setInterval(() => {
                if (!this._allResources.size) {
                    clearInterval(this._closeWaitTimer);
                    this._closeWaitTimer = undefined;
                    return;
                }
                if (Date.now() > startTime + terminateWait) {
                    clearInterval(this._closeWaitTimer);
                    this._closeWaitTimer = undefined;
                    this._acquiredResources.forEach(t => this.release(t.resource));
                    this.emit('terminate');
                }
            }, 50);
        }
        this._setHouseKeep(5);
        this.once('close', callback);
    }
    closeAsync(arg0) {
        return putil_promisify_1.default.fromCallback(cb => this.close(arg0, cb));
    }
    acquire(callback) {
        if (!callback)
            return putil_promisify_1.default.fromCallback(cb => this.acquire(cb));
        try {
            this.start();
        }
        catch (e) {
            return callback(e);
        }
        if (this.options.maxQueue && this.pending >= this.options.maxQueue) {
            return callback(new Error('Pool queue is full'));
        }
        this._requestQueue.push(new pool_request_js_1.PoolRequest(this, callback));
        this._processNextRequest();
    }
    /**
     * Releases an allocated `resource` and let it back to pool.
     */
    release(resource, callback) {
        const item = this._allResources.get(resource);
        if (item && item.state !== definitions_js_1.ResourceState.IDLE) {
            this._itemSetIdle(item, callback);
        }
        this._processNextRequest();
    }
    /**
     * Async version of release().
     */
    releaseAsync(resource) {
        return putil_promisify_1.default.fromCallback(cb => this.release(resource, cb));
    }
    /**
     * Releases, destroys and removes any `resource` from `Pool`.
     */
    destroy(resource, callback) {
        try {
            const item = this._allResources.get(resource);
            if (item)
                this._itemDestroy(item, callback);
            else if (callback)
                callback();
        }
        finally {
            this._processNextRequest();
        }
    }
    /**
     * Async version of destroy().
     */
    destroyAsync(resource) {
        return putil_promisify_1.default.fromCallback(cb => this.destroy(resource, cb));
    }
    /**
     * Returns if a `resource` has been acquired from the pool and not yet released or destroyed.
     */
    isAcquired(resource) {
        const item = this._allResources.get(resource);
        return !!(item && item.acquiredNode);
    }
    /**
     * Returns if the pool contains a `resource`
     */
    includes(resource) {
        return this._allResources.has(resource);
    }
    _processNextRequest() {
        if (this._state !== definitions_js_1.PoolState.STARTED ||
            this._requestsProcessing >= this.options.max - this.acquired) {
            return;
        }
        const request = this._requestQueue.shift();
        if (!request)
            return;
        this._requestsProcessing++;
        const handleCallback = (err, item) => {
            this._requestsProcessing--;
            request.stopTimout();
            try {
                if (item) {
                    /* istanbul ignore next : Hard to simulate */
                    if (this._state !== definitions_js_1.PoolState.STARTED) {
                        this._itemDestroy(item);
                        return;
                    }
                    this._itemSetAcquired(item);
                    this._ensureMin();
                    request.callback(undefined, item.resource);
                    this.emit('acquire', item.resource);
                }
                else
                    request.callback(err);
            }
            catch (ignored) {
                // ignored
            }
            this._processNextRequest();
        };
        const item = this._idleResources.shift();
        if (item) {
            /* Validate resource */
            if (this.options.validation && this._factory.validate) {
                this._itemValidate(item, (err) => {
                    /* Destroy resource on validation error */
                    if (err) {
                        this._itemDestroy(item);
                        this.emit('validate-error', err, item.resource);
                        this._requestsProcessing--;
                        this._requestQueue.unshift(request);
                        this._processNextRequest();
                    }
                    else
                        handleCallback(undefined, item);
                });
                return;
            }
            return handleCallback(undefined, item);
        }
        /** There is no idle resource. We need to create new one **/
        this._createResource(request, handleCallback);
    }
    emit(event, ...args) {
        // Prevents errors while calling emit()
        try {
            return super.emit(event, ...args);
        }
        catch (e) {
            return true;
        }
    }
    /**
     * Creates new resource
     */
    _createResource(request, callback) {
        const maxRetries = this.options.acquireMaxRetries;
        let tries = 0;
        this._creating++;
        const handleCallback = (err, obj) => {
            if (request && request.timedOut)
                return;
            if (err || !obj) {
                tries++;
                this.emit('error', err, {
                    requestTime: request ? request.created : Date.now(),
                    tries,
                    maxRetries: this.options.acquireMaxRetries,
                });
                if (err instanceof abort_error_js_1.AbortError || tries >= maxRetries) {
                    this._creating--;
                    return callback && callback(err);
                }
                return setTimeout(() => tryCreate(), this.options.acquireRetryWait);
            }
            this._creating--;
            if (this._allResources.has(obj)) {
                return (callback &&
                    callback(new Error('Factory error. Resource already in pool')));
            }
            const item = new resource_item_js_1.ResourceItem(obj);
            this._itemSetIdle(item);
            this._allResources.set(obj, item);
            if (callback)
                callback(undefined, item);
            this.emit('create', obj);
        };
        const tryCreate = () => {
            try {
                const o = this._factory.create({ tries, maxRetries });
                /* istanbul ignore next */
                if (!o) {
                    return handleCallback(new abort_error_js_1.AbortError('Factory returned no resource'));
                }
                putil_promisify_1.default.await(o, handleCallback);
            }
            catch (e) {
                handleCallback(e);
            }
        };
        tryCreate();
    }
    _setHouseKeep(ms) {
        if (this._houseKeepTimer)
            clearInterval(this._houseKeepTimer);
        this._houseKeepTimer = undefined;
        if ((ms > 0 && this.state === definitions_js_1.PoolState.STARTED) ||
            this.state === definitions_js_1.PoolState.CLOSING) {
            this._houseKeepTimer = setInterval(() => this._houseKeep(), ms);
        }
    }
    _houseKeep() {
        const isClosing = this._state === definitions_js_1.PoolState.CLOSING;
        const now = Date.now();
        let m = this._allResources.size - this.options.min;
        let n = this._idleResources.length - this.options.minIdle;
        if (isClosing || (m > 0 && n > 0)) {
            this._idleResources.every((item) => {
                if (isClosing || item.idleTime + this.options.idleTimeoutMillis < now) {
                    this._itemDestroy(item);
                    return isClosing || !!(--n && --m);
                }
                return false;
            });
        }
        if (isClosing) {
            /* Check again 5 ms later */
            if (this._allResources.size)
                return;
            clearInterval(this._houseKeepTimer);
            this._state = definitions_js_1.PoolState.CLOSED;
            this._requestsProcessing = 0;
            this.emit('close');
        }
    }
    _ensureMin() {
        process.nextTick(() => {
            let k = Math.max(this.options.min - this._allResources.size, this.options.minIdle - this._idleResources.length) - this.creating;
            while (k-- > 0)
                this._createResource();
        });
    }
    _itemSetAcquired(item) {
        if (item.state !== definitions_js_1.ResourceState.ACQUIRED) {
            this._itemDetach(item);
            item.state = definitions_js_1.ResourceState.ACQUIRED;
            this._acquiredResources.push(item);
            item.acquiredNode = this._acquiredResources.tail;
        }
    }
    _itemDetach(item) {
        switch (item.state) {
            case definitions_js_1.ResourceState.IDLE:
                item.idleTime = 0;
                /* istanbul ignore next*/
                if (item.idleNode)
                    item.idleNode.remove();
                item.idleNode = undefined;
                break;
            case definitions_js_1.ResourceState.ACQUIRED:
            case definitions_js_1.ResourceState.VALIDATION:
                /* istanbul ignore next*/
                if (item.acquiredNode)
                    item.acquiredNode.remove();
                item.acquiredNode = undefined;
                break;
            default:
                break;
        }
    }
    _itemSetIdle(item, callback) {
        const isAcquired = item.state === definitions_js_1.ResourceState.ACQUIRED;
        const handleCallback = (err) => {
            if (err)
                return this._itemDestroy(item, callback);
            this._itemDetach(item);
            item.idleTime = Date.now();
            item.state = definitions_js_1.ResourceState.IDLE;
            if (this.options.fifo) {
                this._idleResources.push(item);
                item.idleNode = this._idleResources.tail;
            }
            else {
                this._idleResources.unshift(item);
                item.idleNode = this._idleResources.head;
            }
            if (isAcquired)
                this.emit('return', item.resource);
            if (callback)
                callback();
            // noinspection JSAccessibilityCheck
            this._processNextRequest();
        };
        if (isAcquired && this._factory.reset) {
            try {
                const o = this._factory.reset(item.resource);
                putil_promisify_1.default.await(o, handleCallback);
            }
            catch (e) {
                handleCallback(e);
            }
        }
        else
            handleCallback();
    }
    _itemDestroy(item, callback) {
        this._itemDetach(item);
        const handleCallback = (err) => {
            if (err) {
                this.emit('destroy-error', err, item.resource);
                /* istanbul ignore next */
                return callback && callback(err);
            }
            this.emit('destroy', item.resource);
            item.destroyed = true;
            if (callback)
                callback();
        };
        try {
            this._allResources.delete(item.resource);
            this._processNextRequest();
            const o = this._factory.destroy(item.resource);
            putil_promisify_1.default.await(o, handleCallback);
        }
        catch (e) {
            handleCallback(e);
        }
    }
    _itemValidate(item, callback) {
        item.state = definitions_js_1.ResourceState.VALIDATION;
        try {
            const o = this._factory.validate?.(item.resource);
            // @ts-ignore
            putil_promisify_1.default.await(o, callback);
        }
        catch (e) {
            if (callback)
                callback(e);
        }
    }
}
exports.Pool = Pool;
